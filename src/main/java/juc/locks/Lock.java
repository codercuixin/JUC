package juc.locks;
import java.util.concurrent.TimeUnit;

/**
 * 与使用{@code synchronized}方法和语句相比，{@code Lock}锁实现提供了更广泛的锁操作。
 * 它们允许更灵活的结构，可以具有完全不同的属性，并且可以支持多个关联的{@link Condition} 对象。
 *
 * <p> 锁是一种用于控制多个线程对共享资源访问的工具。
 *  通常，锁提供对共享资源的独占访问：一次只能有一个线程可以获取该锁，而对共享资源的所有访问都需要首先获取该锁。
 *  但是，某些锁可能允许并发访问共享资源，例如{@link ReadWriteLock}的读取锁。
 *
 * <p>使用{@code synchronized}方法或语句可访问与每个对象关联的隐式monitor锁，但会强制所有锁的获取和释放以块结构的方式发生:
 *  当获取多个锁时，它们必须以相反的顺序释放，并且所有锁必须在与获得这些锁的相同词法作用域内释放。
 *
 *  <p> 尽管用于{@code synchronized}方法和语句的作用域机制让使用monitor锁的编程变得更加容易，
 *  并有助于避免许多常见的涉及锁的编程错误，但在某些情况下，你需要以更灵活的方式使用锁。
 *  例如，某些用于遍历并发访问的数据结构的算法需要使用“hand-over-hand”或“chain locking”：
 *  你获取节点A的锁，然后获取节点B的锁，然后释放A并获取C，然后释放B并获得D等。
 *  Lock接口的实现通过允许在不同范围内获取和释放锁，并允许以任意顺序获取和释放多个锁，从而启用了此类技术。
 *
 *  <p>灵活性的提高带来了更多的责任。
 *  缺少块结构锁定将消除{@code synchronized}方法和语句相关的自动锁定释放。
 *  在大多数情况下，应使用以下惯用法：
 *
 *  <pre> {@code
 * Lock l = ...;
 * l.lock();
 * try {
 *   // 通过这把锁的保护来访问资源
 * } finally {
 *   l.unlock();
 * }}</pre>
 *
 * 当加锁和解锁发生在不同的范围内时，必须小心以确保通过try-finally或try-catch保护在持有锁时执行的所有代码，以确保在必要时释放锁。
 * <p>{@code Lock}锁实现通过使用非阻塞尝试获取锁({@link #tryLock()})，尝试获取可被中断的锁({@link #lockInterruptibly()})
 * 以及尝试可能超时的锁({@link #tryLock(long, TimeUnit)})来提供比同步方法和语句更多的功能。
 *
 * <p>{@code Lock}类还可以提供与隐式monitor锁完全不同的行为和语义，例如保证顺序，不可重用或死锁检测。
 * 如果实现类提供了这种特殊的语义，则实现必须记录这些语义。
 *
 * <p>请注意，Lock实例只是普通对象，它们本身可以用作{@code synchronized}语句中的目标。
 * 获取Lock实例的monitor锁定与调用该实例的任何{@link #lock()})方法没有指定的关系。
 * 建议避免混淆，除非在自己的实现中使用，否则不要以这种方式使用Lock实例。
 *
 * <p>除非另有说明，否则为任何参数传递{@code null}值都会导致引发{@link NullPointerException}。
 *
 * <h3>内存同步</h3>
 *
 * <p>所有{@code Lock}锁实现必须强制执行与内置monitor锁所提供的相同的内存同步语义，如Java语言规范（17.4内存模型）中所述：
 * <ul>
 * <li>成功的{@code lock}操作与成功的<em>Lock</em>操作具有相同的内存同步效果。</li>
 * <li>成功的{@code unlock}操作与成功的<em>Unlock</em>操作具有相同的内存同步效果。</li>
 * </ul>
 * 不成功的加锁和解锁操作以及可重入的加锁/解锁操作不需要任何内存同步效果。
 *
 * <h3>实现注意事项</h3>
 * <p>锁获取的三种形式（可中断，不可中断和定时）在其性能特征，顺序保证或其他实现质量上可能有所不同。
 * 此外，在给定的{@code Lock}类中，可能无法提供中断正在进行的锁获取的功能。
 * 因此，不需要为所有三种形式的锁获取定义完全相同的保证或语义的实现，也不需要支持正在进行的锁获取的中断的实现。
 * 需要一个实现来清楚地记录每个锁定方法提供的语义和保证。
 * 它还必须遵守这个接口中定义的中断语义，某种意义上锁获取的中断会被这样支持:要么完全支持，要么只支持方法入口。
 *
 * <p>由于中断通常意味着取消，而且对中断的检查通常不频繁，所以实现可能更倾向于响应中断，而不是正常的方法返回。
 * 即使可以显示在另一个操作之后发生的中断可能已经解除了线程阻塞，这也是正确的。实现应该记录这种行为。
 *
 * @see ReentrantLock
 * @see Condition
 * @see ReadWriteLock
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface Lock {

    /**
     * 获得锁。
     *
     * <p>如果锁不可用，则当前线程将出于线程调度目的而禁用，并处于休眠状态，直到获得锁为止。
     *
     * <p><b>实现注意事项</b>
     *
     * <p>A {@code Lock}实现可能能够检测锁的错误使用，
     * 例如导致死锁的调用，并可能在这种情况下抛出(未经检查的)异常。
     * 该锁实现必须记录这种情况和异常类型。
     */
    void lock();

    /**
     * 除非当前线程被中断{@linkplain Thread#interrupt()}，否则获取锁。
     *
     * <p>如果锁可用，则获取锁并立即返回。
     * <p>如果锁不可用，那么当前线程将出于线程调度的目的被禁用，并处于休眠状态，直到发生以下两种情况之一:
     * <ul>
     * <li>锁被当前线程获取;或
     * <li>其他一些线程中断{@linkplain Thread#interrupt()}当前线程，支持锁获取的中断。
     * </ul>
     *
     * <p>如果当前线程:
     * <ul>
     * <li>在进入此方法时已设置其中断状态;或
     * <li>获取锁时被中断{@linkplain Thread#interrupt()}，支持锁获取的中断，
     * 然后抛出{@link InterruptedException}，并清除当前线程的中断状态。
     * </ul>
     *
     *
     * <p><b>实现注意事项</b>
     *
     * <p>在某些实现中中断锁的获取的能力可能是不可能的，而且即便可能的话，这可能是一个昂贵的操作。
     * 程序员应该意识到情况可能是这样的。在这种情况下，实现应该记录。
     *
     * <p>实现可能更倾向于响应中断而不是正常的方法返回。
     *
     * <p>A {@code Lock}实现可能能够检测锁的错误使用，
     * 例如导致死锁的调用，并可能在这种情况下抛出(未经检查的)异常。
     * 该锁实现必须记录这种情况和异常类型。
     *
     * @throws InterruptedException 如果获取锁时当前线程被中断（并且支持锁获取的中断）
     */
    void lockInterruptibly() throws InterruptedException;

    /**
     * 仅当在调用方法时锁处于空闲状态时，才获取锁。
     *
     * <p>如果锁可用，则获取锁并立即返回值true。如果锁不可用，则此方法将立即返回值false。
     *
     * <p>这种方法的典型用法是：
     *  <pre> {@code
     * Lock lock = ...;
     * if (lock.tryLock()) {
     *   try {
     *     // manipulate protected state
     *   } finally {
     *     lock.unlock();
     *   }
     * } else {
     *   // perform alternative actions
     * }}</pre>
     *
     * 此用法可确保在获取锁后将其解锁，并且在未获取锁时不会尝试解锁。
     *
     * @return {@code true} 如果锁被成功获取就返回true
     *         {@code false} 否则返回false
     */
    boolean tryLock();

    /**
     * 如果在给定的等待时间内锁是空闲的并且当前线程没有被中断{@linkplain Thread#interrupt()}，则获取锁。
     *
     * <p>如果锁可用，则此方法立即返回值true。
     * 如果锁不可用，那么当前线程将出于线程调度的目的而被禁用，并处于休眠状态，直到发生以下三种情况之一:
     * <ul>
     * <li>锁被当前线程获取;或
     * <li>其他线程中断当前线程，支持锁获取的中断;或
     * <li>指定的等待时间已经过了
     * </ul>
     *
     * <p>如果获得锁，则返回true值。
     *
     * <p>如果当前线程:
     * <ul>
     * </ul>在进入此方法时已设置其中断状态;或
     * </ul>获取锁时中断，支持锁获取中断，
     * 然后抛出InterruptedException，并清除当前线程的中断状态。
     * </ul>
     *
     * <p>如果指定的等待时间过期，则返回false值。如果时间小于或等于0，则该方法根本不会等待。
     *
     * <p><b>实现注意事项</b>
     *
     * <p>在某些实现中中断锁的获取的能力可能是不可能的，而且即便可能的话，这可能是一个昂贵的操作。
     * 程序员应该意识到情况可能是这样的。在这种情况下，实现应该记录。
     *
     * <p>实现可能更倾向于响应中断而不是正常的方法返回。
     *
     * <p>A {@code Lock}实现可能能够检测锁的错误使用，
     * 例如导致死锁的调用，并可能在这种情况下抛出(未经检查的)异常。
     * 该锁实现必须记录这种情况和异常类型。
     *
     * @param time 等待锁的最大时间
     * @param unit 参数time的时间单位
     * @return {@code true} 如果获取锁成功就返回ture
     *         {@code false} 并且如果还没获取锁时间就过了，就返回false。
     * @throws InterruptedException 如果获取锁时当前线程被中断（并且支持锁获取的中断）
     */
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;

    /**
     * 释放锁。
     *
     * <p><b>实现注意事项</b>
     * 锁实现通常会对哪个线程可以释放锁施加限制(通常只有锁的持有者可以释放锁)，
     * 如果违反了限制，可能会抛出(未经检测的)异常。
     * 任何限制和异常类型都必须由锁实现记录下来。
     */
    void unlock();

    /**
     * 返回绑定到此Lock实例的新{@link Condition}实例。
     *
     * <p>在等待该条件之前，该锁必须由当前线程持有。
     * 调用{@link Condition#await()}会在等待之前自动释放锁，并在等待返回之前重新获取该锁。
     *
     * <p><b>实现注意事项</b>
     *
     * {@link Condition}实例的确切操作取决于{@link Lock}实现，并且必须由该实现记录。
     *
     * @return 返回给Lock实例的一个新的Condition实例
     * @throws UnsupportedOperationException 如果此Lock实现不支持Condition。
     */
    Condition newCondition();
}
