package juc.locks;

/**
 *  ReadWriteLock维护一对关联的锁，一个用于只读操作，一个用于写入。
 *  只要没有写线程，读锁({@link #readLock)就可以同时由多个读线程持有。
 *  写锁({@link #writeLock})是排他的。
 *
 * <p>所有ReadWriteLock实现都必须确保writeLock操作（在Lock接口中指定）的内存同步效果对于关联的readLock也保持不变。
 * 也就是说，成功获取读锁的线程将看到在先前释放写锁时所做的所有更新。
 *
 * <p>与互斥锁相比，读写锁在访问共享数据时允许更高级别的并发性。
 * 它利用了这样的事实：虽然一次只能有一个线程（一个写线程）可以修改共享数据，但在许多情况下，任何数量的线程都可以同时读取数据（因此有多个读线程）。
 * 从理论上讲，与使用互斥锁相比，使用读写锁允许的并发性增加将导致性能提高。
 * 在实践中，并发性的增加只能在多处理器上完全实现，并且同时要求共享数据的访问模式合适。
 *
 * <p>读写锁是否会比使用互斥锁提高性能，取决于与修改相比读取数据的频率，读取和写入操作的持续时间以及对数据的争用( 即，将尝试同时读取或写入数据的线程的数目）。
 * 例如，初始化时使用数据填充，之后不经常修改但经常搜索的集合（例如某种目录）是使用读写锁的理想选择。
 * 但是，如果更新变得频繁，那么数据将花费大部分时间用于独占地加锁，因而即便并发有提高，也会很少。
 * 此外，如果读操作太短，读写锁实现的开销(其本质上比互斥锁更复杂)可能会控制执行成本，特别是因为许多读写锁实现仍然通过一小段代码序列化所有线程。
 * 最终，只有分析和度量才能确定读写锁的使用是否适合你的应用程序。
 *
 * <p>尽管读写锁的基本操作很简单，但是实现必须做出许多策略决策，这可能会影响给定应用程序中读写锁的有效性。
 * 这些策略的示例包括：
 * <ul>
 * <li>当读线程和写线程都在等待锁时，在写线程释放写锁时，确定是授予读锁还是写锁。
 * 偏向写线程锁是常见的，因为写线程被认为是短而不频繁的。
 * 偏向授予读线程锁则不那么常见，因为如果读线程如预期的那样频繁且长期存在，则会导致写线程的长时间延迟。公平锁或“顺序”锁也是可能的实现。
 * <li>在读线程处于活动状态而写线程正在等待时，确定请求读锁的读线程是否被授予读锁。
 * 对读线程的偏爱会无限期地延迟写操作，而对写线程的偏爱则会降低并发的可能性。
 * <li>确定锁是否可重入:具有写锁的线程可以重新获得它吗?它能在持有写锁的同时获取读锁吗?读锁本身是可重入的吗?
 * <li> 是否可以将写锁降级为读锁而不允许插入写线程?是否可以优先于其他等待的读线程或写线程，将读锁升级为写锁?
 * </ul>
 * 在评估某个特定实现是否适合你的应用程序时，你应该考虑所有这些因素。
 *
 * @see ReentrantReadWriteLock
 * @see Lock
 * @see ReentrantLock
 *
 * @since 1.5
 * @author Doug Lea
 */
public interface ReadWriteLock {
    /**
     * 返回用于读取的锁
     *
     * @return the lock used for reading
     */
     Lock readLock();

    /**
     * 返回用于写入的锁
     *
     * @return the lock used for writing
     */
     Lock writeLock();
}
